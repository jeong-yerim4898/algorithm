#DP의 기본적인 문제
#

# 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
#
# 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
# 2.X가 2로 나누어 떨어지면, 2로 나눈다.
# 3. 1을 뺀다.
# 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

N = int(input())

dp = [0 for _ in range(N+1)] #인덱스를 맞추기 위해
dp[2]=1 #2는 2로 나눌때 1로 뺄 떄 2가지가 존재히지만 최솟값이기 떄문에 1
dp[3]=1 # 3은 3으로 나눌때 1 한가지
# 기본으로 2가지르 미리 설정 해둠으로 반복을 줄인다.
for i in range(4,N+1):
    # 1을 더하는 이유는 단계의 값을 기억하기 위해서이다.
    # i가 4라면 1을 뺀 3 or 2를 나누 2일 떄로 나누어 진다. 2,3 인덱스에 저장된 값 (= 인덱스 해당 최소 단계값)
    # 1을 더해 더 작은 값을 해당 인덱스에 넣어준다.
    dp[i]=dp[i-1]+1 #1을 뺴는 경우
    if not i%2 and dp[i]>dp[i//2]+1: #2로 나누어 지는 경우
        dp[i] = dp[i//2]+1
    if not i%3 and dp[i]>dp[i//3]+1: # 3으로 나누어 지는 경우
        dp[i]=dp[i//3]+1

print(dp[N])